#!/usr/bin/env php
<?php

// Find and initialize Composer
use Psr\Log\LoggerInterface;
use Psr\Log\LogLevel;
use Resque\Logger;
use Resque\Redis as ResqueRedis;
use Resque\Resque;
use Resque\Worker\ResqueWorker;

$files = array(
    __DIR__ . '/../../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
    __DIR__ . '/../../../../autoload.php',
    __DIR__ . '/../vendor/autoload.php',
);

$found = false;
foreach ($files as $file) {
    if (file_exists($file)) {
        require_once $file;
        break;
    }
}

$QUEUE = getenv('QUEUE');
if(!is_string($QUEUE) || trim($QUEUE) === '') {
    die("Set QUEUE env var containing the list of queues to work.\n");
}

/**
 * REDIS_BACKEND can have simple 'host:port' format or use a DSN-style format like this:
 * - redis://user:pass@host:port
 *
 * Note: the 'user' part of the DSN URI is required but is not used.
 */
$REDIS_BACKEND = getenv('REDIS_BACKEND');

// A redis database number
$REDIS_BACKEND_DB = getenv('REDIS_BACKEND_DB');

if (is_string($REDIS_BACKEND) && trim($REDIS_BACKEND) !== '') {
    if (!is_string($REDIS_BACKEND_DB) || trim($REDIS_BACKEND_DB) === '') {
        Resque::setBackend($REDIS_BACKEND);
    } else {
        Resque::setBackend($REDIS_BACKEND, (int)$REDIS_BACKEND_DB);
    }
}

$logLevel = false;
$LOGGING = getenv('LOGGING');
$VERBOSE = getenv('VERBOSE');
$VVERBOSE = getenv('VVERBOSE');

if (is_string($LOGGING) && trim($LOGGING) !== '' || is_string($VERBOSE) && trim($VERBOSE) !== '') {
    $logLevel = true;
} elseif (is_string($VVERBOSE) && trim($VVERBOSE) !== '') {
    $logLevel = true;
}

$APP_INCLUDE = getenv('APP_INCLUDE');

if (is_string($APP_INCLUDE) && trim($APP_INCLUDE) !== '') {
    if(!file_exists($APP_INCLUDE)) {
        die('APP_INCLUDE (' . $APP_INCLUDE . ") does not exist.\n");
    }

    require_once $APP_INCLUDE;
}

// See if the APP_INCLUDE contains a logger object,
// If none exists, fallback to internal logger
if (!isset($logger) || !($logger instanceof LoggerInterface)) {
    $logger = new Logger($logLevel);
}

$BLOCKING = getenv('BLOCKING') !== false;

$interval = 5;
$INTERVAL = getenv('INTERVAL');
if (is_string($INTERVAL) && trim($INTERVAL) !== '') {
    $interval = (int)$INTERVAL;
}

$count = 1;
$COUNT = getenv('COUNT');

if (is_string($COUNT) && trim($COUNT) !== '' && (int)$COUNT > 1) {
    $count = $COUNT;
}

$PREFIX = getenv('PREFIX');

if (is_string($PREFIX) && trim($PREFIX) !== '') {
    $logger->log(LogLevel::INFO, 'Prefix set to {prefix}', array('prefix' => $PREFIX));
    ResqueRedis::prefix($PREFIX);
}

/**
 * @param int $signal
 * @return void
 */
function cleanup_children($signal): void
{
    $GLOBALS['send_signal'] = $signal;
}

if($count > 1) {
    $children = array();

    /** @var array{ send_signal: int|false } $GLOBALS */
    $GLOBALS['send_signal'] = false;

    $die_signals = array(SIGTERM, SIGINT, SIGQUIT);
    $all_signals = array_merge($die_signals, array(SIGUSR1, SIGUSR2, SIGCONT, SIGPIPE));

    for($i = 0; $i < $count; ++$i) {
        $pid = Resque::fork();
        if ($pid === false) {
            die("Could not fork worker " . $i . "\n");
        } elseif ($pid === 0) {
            // Child, start the worker
            $queues = explode(',', $QUEUE);
            $worker = new ResqueWorker($queues);
            $worker->setLogger($logger);
            $worker->hasParent = true;
            fwrite(STDOUT, '*** Starting worker ' . $worker . "\n");
            $worker->work($interval);
            break;
        } else {
            $children[$pid] = 1;
            while (count($children) == $count) {
                if (!isset($registered)) {
                    declare(ticks=1);
                    foreach ($all_signals as $signal) {
                        pcntl_signal($signal, "cleanup_children");
                    }

                    $PIDFILE = getenv('PIDFILE');
                    if (is_string($PIDFILE) && trim($PIDFILE) !== '') {
                        if(file_put_contents($PIDFILE, getmypid()) === false) {
                            $logger->log(LogLevel::NOTICE, 'Could not write PID information to {pidfile}', array('pidfile' => $PIDFILE));
                            die(2);
                        }
                    }

                    $registered = true;
                }

                if(function_exists('setproctitle')) {
                    setproctitle('resque-' . Resque::VERSION . ": Monitoring {$count} children: [" . implode(',', array_keys($children)) . "]");
                }

                $childPID = pcntl_waitpid(-1, $childStatus, WNOHANG);
                if ($childPID != 0) {
                    fwrite(STDOUT, "*** A child worker died: {$childPID}\n");
                    unset($children[$childPID]);
                    $i--;
                }
                usleep(250000);
                if ($GLOBALS['send_signal'] !== false) {
                    foreach ($children as $k => $v) {
                        posix_kill($k, $GLOBALS['send_signal']);
                        if (in_array($GLOBALS['send_signal'], $die_signals, true)) {
                            pcntl_waitpid($k, $childStatus);
                        }
                    }
                    if (in_array($GLOBALS['send_signal'], $die_signals, true)) {
                        exit;
                    }
                    $GLOBALS['send_signal'] = false;
                }
            }
        }
    }
}
// Start a single worker
else {
    $queues = explode(',', $QUEUE);
    $worker = new ResqueWorker($queues);
    $worker->setLogger($logger);
    $worker->hasParent = false;

    $PIDFILE = getenv('PIDFILE');
    if (is_string($PIDFILE) && trim($PIDFILE) !== '') {
        if(file_put_contents($PIDFILE, getmypid()) === false) {
            $logger->log(LogLevel::NOTICE, 'Could not write PID information to {pidfile}', array('pidfile' => $PIDFILE));
            die(2);
        }
    }

    $logger->log(LogLevel::NOTICE, 'Starting worker {worker}', array('worker' => $worker));
    $worker->work($interval, $BLOCKING);
}
